# 1.1.7 Example: Square Roots by Newton's Method.

Procedures, as intorduced above, are much like oridnary mathematical functions. They specify a value that is determined by one ore more paramenters. But there is an important differeence between mathematica functions and computer procedures. Procedures must be effective.

As a case in point, consider the problem of computing square roots. We can define the square-root functions as

`sqrt(x) = the y such that y >=0 and y*2 == x`

This describes a perfectly legitimate mathematical function. We could use it to recognize whether one number is the squrare root of another, or to derive fact about square roots in general. On the other hand, the definition does not describe a procedure. Indeed, it tells us almost nothing about how to actually find the square root of a given number. It will not help matters of peharase this definition in pseudo-Lisp:

```lisp
(deifne (sqrt x)
(the y (and (>= y0) (= (square y) x))s))
```

This only begs the question.

The contrast between function ad procedure is a reflection of the general distincion betweeen describing properites of things and describing how to do things, or, as iti t sometimes reffered to, the distinction between declarative knowledge and imperative knowledge. In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usully concerned with imperative (how to) descriptions.

Declarative and imperative descriptions are intimately related, ad indeed are mathematics and computer sceince. For instance, to say that the answer produced by a porgram is "correct" is to make declaratie statement about the program. There is a large amount of research aimed at establishing techniques for proving that programs are correct, and much of the technical difficulty of this subject has to do with negotiation the transition between imparative statements (from which programs are constructed) and declarative statements (which can be sued to deduce things). in a related vein, an important current area in programming-language design is the exploration of so-called very hight-level languages, in which one actually programs in terms of declarative statements. The idea is to make interpreters sophisticated enoush so that, given "what is" knowledge specified by the programmer, they can generate "how to" knowledge automatically. This cannot be done in general, but there are important areas where progress has been madde. We shall revisit this indea in Chapter 4.



How does one compute square roots? The most common way is to use Newton's method of successive approximations, which says  that whenever we have a guess `y` fo  the value of the square root of a number `x`, we can perform a simple manipulation to get a better guess (one close to the acutal square root) by averating `y` with `x/y`.

This square root algorithm is actually a special case of Newton's method, which is a general technique for finding roots of equations. The square-root algorithm itslef was developed by Heron of Alexandria in the first sentuary A.D. We will see how to eapress the general Newton's method as a List procedure in Sections 1.3.4.